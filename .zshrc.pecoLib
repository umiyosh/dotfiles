#!/usr/bin/env zsh

# source action define
function _sshSourceAction() {
  # candidates was written by NAKAMURA Yoshitaka
  # Copyright (c) 2011, NAKAMURA Yoshitaka
  # All rights reserved. BSD-3.
  # https://github.com/zsh-users/zaw/blob/master/LICENSE
  local -a _global_ssh_known_hosts _global_ssh_known_hosts2 _ssh_known_hosts _ssh_known_hosts2 _etc_hosts _ssh_config_hosts
  [ -r /etc/ssh/ssh_known_hosts ] && _global_ssh_known_hosts=(${${${(f)"$(< /etc/ssh/ssh_known_hosts)"}%%\ *}%%,*}) 2>/dev/null || _global_ssh_known_hosts=()
  [ -r /etc/ssh/ssh_known_hosts2 ] && _global_ssh_known_hosts2=(${${${(f)"$(< /etc/ssh/ssh_known_hosts2)"}%%\ *}%%,*}) 2>/dev/null || _global_ssh_known_hosts2=()
  [ -r "$HOME/.ssh/known_hosts" ] && _ssh_known_hosts=(${${${(f)"$(< ~/.ssh/known_hosts)"}%%\ *}%%,*}) 2>/dev/null || _ssh_known_hosts=()
  [ -r "$HOME/.ssh/known_hosts2" ] && _ssh_known_hosts=(${${${(f)"$(< ~/.ssh/known_hosts2)"}%%\ *}%%,*}) 2>/dev/null || _ssh_known_hosts2=()
  [ -r /etc/hosts ] && : ${(A)_etc_hosts:=${(s: :)${(ps:\t:)${${(f)~~"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}} || _etc_hosts=()
  [ -r "$HOME/.ssh/config" ] && _ssh_config_hosts=(${${${(@M)${(f)"$(< ~/.ssh/config)"}:#Host *}#Host }:#*[*?]*}) || _ssh_config_hosts=()
  candidates=(
    $_global_ssh_known_hosts[@]
    $_global_ssh_known_hosts2[@]
    $_ssh_known_hosts[@]
    $_ssh_known_hosts2[@]
    $_etc_hosts[@]
    $_ssh_config_hosts[@]
    "$HOST"
    ::1
    localhost
    127.0.0.1
  )
  echo $(echo $candidates |perl -pe 's/ /\n/g'|sort |uniq)
}

# peco after action define
ActionsBuffer=()
# %%STDIN%% command => Source | command
# command           => tmux send-keys command Source
function pecoAfterAction() {
  Actions=($@)
  ActionsBuffer=($Actions)
  Source=( ${(@f)"$(< /dev/stdin|_pecoAfterFilter)"} )
  if [[ $#Actions -gt 1 ]]; then
    Action=$(for Action in $Actions ;do echo $Action;done|peco --prompt "SELECT ACTION >>"|head -1)
  else
    Action=$Actions
  fi
  if [[ -z $Source || -z $Action ]]; then
    echo
    echo nothing selected
    return
  fi
  if [[ $Action =~ ^%%STDIN%% ]]; then
    Action=$(echo $Action | perl -pe 's/^%%STDIN%% +//g')
    ActionScrap=("${(@s/ /)Action}")
    Action=$ActionScrap[1]
    shift ActionScrap
    if [[ ! -z $ActionScrap[1] ]]; then
      for argment in $ActionScrap; do
        argments="$argments $argment"
      done
    fi
    echo $Action $argment > /tmp/wk.log
    for selected in $Source; do
      echo $selected
    done | $Action $argment
  else
    _executeTmuxBuffer "$Action $Source"
  fi
}

function paaInputCommandAny() {
  echo -n "command?:"
  read command
  eval $command $@
}

function paaSafeRm() {
  files=( ${(@f)"$(< /dev/stdin)"} )
  echo $files
  read -q "REPLY?This is the question I want to ask?"
  echo    # (optional) move to a new line
  if [[ $REPLY =~ ^[Yy]$ ]]
  then
    for file in $files; do
      file=$(echo $file | perl -pe 's{\\}{}g')
      if [[ $file != '/' ]]; then
        rm -rf $file </dev/tty
      else
        echo can not recursive delete /
      fi
    done
  fi
}

function paaExecuteAsCommand() {
  Actions=( ${(@f)"$(< /dev/stdin)"} )
  for Action in $Actions; do
    if [[ $Action =~ ^/ ]]; then
      _executeTmuxBuffer "$Action"
    elif which $(echo $Action| awk '{print $1}') >/dev/null; then
      _executeTmuxBuffer "$Action"
    else
      _executeTmuxBuffer "./$Action"
    fi
  done
}

function paaKill() {
  PIDS=( ${(@f)"$(< /dev/stdin)"} )
  SINGNAL=$1
  for pid in $PIDS; do
    kill $SINGNAL $pid
  done
}

function _executeTmuxBuffer() {
  Commands=($@)
  print -z $Commands
  tmux send-keys C-m
}

function _pasteTmuxBuffer() {
  Commands=($@)
  print -z $Commands
}

function paaTovim() {
  tovim | pecoAfterAction $ActionsBuffer
}

# input filter
## peco前処理フィルター: pecoに渡す前の見栄えの調整
function _pecoBeforeFilter() {
  _removeColor | _trim
}

function _removeColor()
{
  # TODO:-rと-Eの分岐
  col | sed -E "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

function _trim() {
  sed 's,^ *,,; s, *$,,'
}

## afteraction後処理フィルター
function _pecoAfterFilter() {
  Sources=( ${(@f)"$(< /dev/stdin)"} )
  for Source in $Sources
  do
    if [[ -e $Source ]]; then
      echo $Source | _getAbsolutePath | _escapePath
    elif [[ $Source =~ '^-[a-z0-9]+ ' ]]; then
      echo $Source | _treatGetOptions
    else
      echo $Source
    fi
  done
}

function _escapePath()
{
  while read value
  do
    printf "%q\n" "$value"|perl -pe 's/\\/\\\\/g'
  done
}

function _getAbsolutePath() {
  if [[ -n $1 ]]; then
    pathstrSub="$1/"
  else
    pathstrSub=""
  fi
  while read pathstr;do
    case "${OSTYPE}" in
      freebsd*|darwin*)
        absolutePath=$(greadlink -f ${pathstrSub}$pathstr)
        ;;
      linux*)
        absolutePath=$(readlink -f ${pathstrSub}$pathstr)
        ;;
    esac
    echo ${absolutePath}
  done
}

function _treatGetOptions() {
  Options=( ${(@f)"$(< /dev/stdin)"} )
  for Option in $Options
  do
    fragments=(${(ps: :)${Option}})
    for fragment in $fragments
    do
      if [[ -e $fragment ]]; then
        echo $fragment | _getAbsolutePath | _escapePath
      else
        echo $fragment
      fi
    done
  done
}

# for widgets function
function zlePasteBuffer() {
  Selected=( ${(@f)"$(< /dev/stdin)"} )
  pasteBuf=$Selected[1]
  shift Selected
  for Action in $Selected; do
      pasteBuf="$pasteBuf ;$Action"
  done
  BUFFER=$pasteBuf
  CURSOR=$#BUFFER
  zle clear-screen
}
function zleExecuteAsCommand() {
  Selected=( ${(@f)"$(< /dev/stdin)"} )
  pasteBuf=$Selected[1]
  shift Selected
  for Action in $Selected; do
      pasteBuf="$pasteBuf ;$Action"
  done
  BUFFER=$pasteBuf
  zle accept-line
}

